/*!
 * Tiny Spelling Autocorrect plugin
 *
 * Copyright (c) 2022 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 1.0.0-44
 */

!function () {
    "use strict";
    const t = t => parseInt(t, 10), e = (t, e) => {
            const r = t - e;
            return 0 === r ? 0 : r > 0 ? 1 : -1
        }, r = (t, e, r) => ({major: t, minor: e, patch: r}), o = e => {
            const o = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(e);
            return o ? r(t(o[1]), t(o[2]), t(o[3])) : r(0, 0, 0)
        }, n = t => e => e.options.get(t), a = n("autocorrect_capitalize"), s = n("autocorrect_autocorrect"),
        c = ("array", t => "array" === (t => {
            const e = typeof t;
            return null === t ? "null" : "object" === e && Array.isArray(t) ? "array" : "object" === e && (r = o = t, (n = String).prototype.isPrototypeOf(r) || (null === (a = o.constructor) || void 0 === a ? void 0 : a.name) === n.name) ? "string" : e;
            var r, o, n, a
        })(t));
    const i = t => "function" == typeof t;

    class u {
        constructor(t, e) {
            this.tag = t, this.value = e
        }

        static some(t) {
            return new u(!0, t)
        }

        static none() {
            return u.singletonNone
        }

        fold(t, e) {
            return this.tag ? e(this.value) : t()
        }

        isSome() {
            return this.tag
        }

        isNone() {
            return !this.tag
        }

        map(t) {
            return this.tag ? u.some(t(this.value)) : u.none()
        }

        bind(t) {
            return this.tag ? t(this.value) : u.none()
        }

        exists(t) {
            return this.tag && t(this.value)
        }

        forall(t) {
            return !this.tag || t(this.value)
        }

        filter(t) {
            return !this.tag || t(this.value) ? this : u.none()
        }

        getOr(t) {
            return this.tag ? this.value : t
        }

        or(t) {
            return this.tag ? this : t
        }

        getOrThunk(t) {
            return this.tag ? this.value : t()
        }

        orThunk(t) {
            return this.tag ? this : t()
        }

        getOrDie(t) {
            if (this.tag) return this.value;
            throw new Error(null != t ? t : "Called getOrDie on None")
        }

        static from(t) {
            return null == t ? u.none() : u.some(t)
        }

        getOrNull() {
            return this.tag ? this.value : null
        }

        getOrUndefined() {
            return this.value
        }

        each(t) {
            this.tag && t(this.value)
        }

        toArray() {
            return this.tag ? [this.value] : []
        }

        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }

    u.singletonNone = new u(!1);
    const l = (t, e, r) => "" === e || t.length >= e.length && t.substr(r, r + e.length) === e,
        p = t => "" === t ? "" : t.charAt(0).toUpperCase() + t.substring(1), g = (t, e) => l(t, e, 0),
        h = (t, e) => l(t, e, t.length - e.length), d = "AutocorrectStart AutocorrectEnd",
        m = "CapitalizeStart CapitalizeEnd", f = t => {
            t.dispatch("AutocorrectStart")
        }, y = t => {
            t.dispatch("AutocorrectEnd")
        }, v = t => t.dispatch("CapitalizeStart"), T = t => t.dispatch("CapitalizeEnd"), _ = (t, e, r) => {
            (r.cache ? e.autocorrect().setAndCache : e.autocorrect().set)(r.on), (r.on ? f : y)(t)
        }, w = (t, e, r) => {
            (r.cache ? e.capitalize().setAndCache : e.capitalize().set)(r.on), (r.on ? v : T)(t)
        }, x = t => {
            let e = t;
            return {
                get: () => e, set: t => {
                    e = t
                }
            }
        }, O = () => {
        }, b = t => () => t, S = t => t, k = t => t(), z = b(!1), A = b(!0), C = Object.keys, E = (t, e) => {
            const r = C(t);
            for (let o = 0, n = r.length; o < n; o++) {
                const n = r[o];
                e(t[n], n)
            }
        }, j = Array.prototype.push, N = {
            normalisation: [new RegExp(["([A-Z][A-Z]+)", "([a-z]+)", "(\\s*)", "$"].join(""))],
            capitalisation: [new RegExp(["([.?!]\\s+)", "([a-z][^\\s]+)", "(\\s*)", "$"].join("")), new RegExp(["^()", "([a-z][^\\s]*)", "(\\s*)", "$"].join(""))],
            autocorrect: [new RegExp(["(^|\\W)", "(\\w+)", "(\\W*)", "(\\s*)", "$"].join(""))]
        }, R = t => {
            const e = ["all", "start", "word", "endOfWord", "space"];
            return {
                regexes: N.autocorrect, identify: r => {
                    if (r && r.length >= e.length) {
                        const e = r[2], o = r[3] + r[4], n = e + o;
                        return t.lookup(e).map((t => ({start: n, replacement: t + o})))
                    }
                    return u.none()
                }
            }
        }, I = (t, e) => (t => {
            const e = [];
            for (let r = 0, o = t.length; r < o; ++r) {
                if (!c(t[r])) throw new Error("Arr.flatten item " + r + " was not an array, input: " + t);
                j.apply(e, t[r])
            }
            return e
        })(((t, e) => {
            const r = t.length, o = new Array(r);
            for (let n = 0; n < r; n++) {
                const r = t[n];
                o[n] = e(r, n)
            }
            return o
        })(e, (e => ((t, e) => {
            for (let r = 0; r < t.length; r++) {
                const o = e(t[r]);
                if (o.isSome()) return o
            }
            return u.none()
        })(e.regexes, (r => {
            const o = t.match(r);
            return null !== o ? e.identify(o) : u.none()
        })).toArray())));
    var J;
    !function (t) {
        t.JSON = "json", t.Blob = "blob", t.Text = "text", t.FormData = "formdata", t.MultipartFormData = "multipart/form-data"
    }(J || (J = {}));
    const P = t => {
            let e = u.none(), r = [];
            const o = t => {
                n() ? a(t) : r.push(t)
            }, n = () => e.isSome(), a = t => {
                e.each((e => {
                    setTimeout((() => {
                        t(e)
                    }), 0)
                }))
            };
            return t((t => {
                n() || (e = u.some(t), ((t, e) => {
                    for (let r = 0, o = t.length; r < o; r++) e(t[r], r)
                })(r, a), r = [])
            })), {
                get: o, map: t => P((e => {
                    o((r => {
                        e(t(r))
                    }))
                })), isReady: n
            }
        }, F = {
            nu: P, pure: t => P((e => {
                e(t)
            }))
        }, D = t => {
            setTimeout((() => {
                throw t
            }), 0)
        }, q = t => {
            const e = e => {
                t().then(e, D)
            };
            return {
                map: e => q((() => t().then(e))),
                bind: e => q((() => t().then((t => e(t).toPromise())))),
                anonBind: e => q((() => t().then((() => e.toPromise())))),
                toLazy: () => F.nu(e),
                toCached: () => {
                    let e = null;
                    return q((() => (null === e && (e = t()), e)))
                },
                toPromise: t,
                get: e
            }
        }, M = t => q((() => new Promise(t))), $ = t => q((() => Promise.resolve(t))), B = t => {
            const e = e => e(t), r = b(t), o = () => n, n = {
                tag: !0,
                inner: t,
                fold: (e, r) => r(t),
                isValue: A,
                isError: z,
                map: e => L.value(e(t)),
                mapError: o,
                bind: e,
                exists: e,
                forall: e,
                getOr: r,
                or: o,
                getOrThunk: r,
                orThunk: o,
                getOrDie: r,
                each: e => {
                    e(t)
                },
                toOptional: () => u.some(t)
            };
            return n
        }, H = t => {
            const e = () => r, r = {
                tag: !1,
                inner: t,
                fold: (e, r) => e(t),
                isValue: z,
                isError: A,
                map: e,
                mapError: e => L.error(e(t)),
                bind: e,
                exists: z,
                forall: A,
                getOr: S,
                or: S,
                getOrThunk: k,
                orThunk: k,
                getOrDie: (o = String(t), () => {
                    throw new Error(o)
                }),
                each: O,
                toOptional: u.none
            };
            var o;
            return r
        }, L = {value: B, error: H, fromOption: (t, e) => t.fold((() => H(e)), B)}, U = t => ({
            ...t,
            toCached: () => U(t.toCached()),
            bindFuture: e => U(t.bind((t => t.fold((t => $(L.error(t))), (t => e(t)))))),
            bindResult: e => U(t.map((t => t.bind(e)))),
            mapResult: e => U(t.map((t => t.map(e)))),
            mapError: e => U(t.map((t => t.mapError(e)))),
            foldResult: (e, r) => t.map((t => t.fold(e, r))),
            withTimeout: (e, r) => U(M((o => {
                let n = !1;
                const a = setTimeout((() => {
                    n = !0, o(L.error(r()))
                }), e);
                t.get((t => {
                    n || (clearTimeout(a), o(t))
                }))
            })))
        }), V = t => U(M(t)), W = t => U($(L.value(t))),
        K = "undefined" != typeof window ? window : Function("return this;")(), Z = t => M((e => {
            const r = new FileReader;
            r.onload = t => {
                const r = t.target ? t.target.result : "";
                e(r)
            }, r.readAsText(t)
        })), G = t => {
            try {
                const e = JSON.parse(t);
                return L.value(e)
            } catch (t) {
                return L.error("Response was not JSON.")
            }
        }, X = t => $(t.response), Q = (t, e) => e.map((e => {
            const r = ((t, e) => {
                const r = [];
                return E(t, ((t, e) => {
                    var o;
                    r.push((o = t, encodeURIComponent(e) + "=" + encodeURIComponent(o)))
                })), r
            })(e), o = ("?", -1 !== t.indexOf("?") ? "&" : "?");
            return r.length > 0 ? t + o + r.join("&") : t
        })).getOr(t), Y = t => V((e => {
            const r = new XMLHttpRequest;
            r.open(t.method, Q(t.url, u.from(t.query)), !0);
            const o = (t => {
                const e = (r = t.body, u.from(r).bind((t => {
                    switch (t.type) {
                        case J.JSON:
                            return u.some("application/json");
                        case J.FormData:
                            return u.some("application/x-www-form-urlencoded; charset=UTF-8");
                        case J.MultipartFormData:
                            return u.none();
                        case J.Text:
                        default:
                            return u.some("text/plain")
                    }
                })));
                var r;
                const o = !0 === t.credentials ? u.some(!0) : u.none(), n = (t => {
                    switch (t) {
                        case J.Blob:
                            return "application/octet-stream";
                        case J.JSON:
                            return "application/json, text/javascript";
                        case J.Text:
                            return "text/plain";
                        default:
                            return ""
                    }
                })(t.responseType) + ", */*; q=0.01", a = void 0 !== t.headers ? t.headers : {};
                return {
                    contentType: e,
                    responseType: (t => {
                        switch (t) {
                            case J.JSON:
                                return u.none();
                            case J.Blob:
                                return u.some("blob");
                            case J.Text:
                                return u.some("text");
                            default:
                                return u.none()
                        }
                    })(t.responseType),
                    credentials: o,
                    accept: n,
                    headers: a,
                    progress: i(t.progress) ? u.some(t.progress) : u.none()
                }
            })(t);
            ((t, e) => {
                e.contentType.each((e => t.setRequestHeader("Content-Type", e))), t.setRequestHeader("Accept", e.accept), e.credentials.each((e => t.withCredentials = e)), e.responseType.each((e => t.responseType = e)), e.progress.each((e => t.upload.addEventListener("progress", (t => e(t.loaded, t.total))))), E(e.headers, ((e, r) => t.setRequestHeader(r, e)))
            })(r, o);
            const n = () => {
                ((t, e, r) => ((t, e) => {
                    switch (t) {
                        case J.JSON:
                            return G(e.response).fold((() => X(e)), $);
                        case J.Blob:
                            return (t => u.from(t.response).map(Z).getOr($("no response content")))(e);
                        case J.Text:
                        default:
                            return X(e)
                    }
                })(e, r).map((e => ({
                    message: 0 === r.status ? "Unknown HTTP error (possible cross-domain request)" : `Could not load url ${t}: ${r.statusText}`,
                    status: r.status,
                    responseText: e
                }))))(t.url, t.responseType, r).get((t => e(L.error(t))))
            };
            var a;
            r.onerror = n, r.onload = () => {
                0 !== r.status || g(t.url, "file:") ? r.status < 100 || r.status >= 400 ? n() : ((t, e) => {
                    const r = t => (t => U($(L.error(t))))({message: t, status: e.status, responseText: e.responseText});
                    switch (t) {
                        case J.JSON:
                            return G(e.response).fold(r, W);
                        case J.Blob:
                        case J.Text:
                            return W(e.response);
                        default:
                            return r("unknown data type")
                    }
                })(t.responseType, r).get(e) : n()
            }, (a = t.body, u.from(a).map((t => t.type === J.JSON ? JSON.stringify(t.data) : t.type === J.FormData || t.type === J.MultipartFormData ? (t => {
                const e = new FormData;
                return E(t, ((t, r) => {
                    e.append(r, t)
                })), e
            })(t.data) : t.data))).fold((() => r.send()), (t => {
                r.send(t)
            }))
        })), tt = "2", et = (() => {
            try {
                const t = K.localStorage, e = "__storage_test__";
                return t.setItem(e, e), t.removeItem(e), u.some(t)
            } catch (t) {
                return u.none()
            }
        })().fold((() => {
            const t = {};
            return {
                getItem: e => t[e], setItem: (e, r) => {
                    t[e] = r
                }
            }
        }), (t => ({
            getItem: e => t.getItem("mce." + e), setItem: (e, r) => {
                t.setItem("mce." + e, r)
            }
        }))), rt = (t, e) => {
            const r = ((t, e) => {
                const r = (t => u.from(et.getItem(t)))(t).map(JSON.parse);
                return r.getOr(e)
            })(t, e), o = x(r), n = t => {
                o.set(t)
            };
            return {
                get: () => o.get(), set: n, setAndCache: e => {
                    n(e), ((t, e) => {
                        const r = JSON.stringify(e);
                        et.setItem(t, r)
                    })(t, e)
                }
            }
        };
    (() => {
        tinymce.PluginManager.requireLangPack("autocorrect", "ar,bg_BG,ca,cs,da,de,el,es,eu,fa,fi,fr_FR,he_IL,hi,hr,hu_HU,id,it,ja,kk,ko_KR,ms,nb_NO,nl,pl,pt_BR,pt_PT,ro,ru,sk,sl_SI,sv_SE,th_TH,tr,uk,vi,zh_CN,zh_TW");
        const t = t => (t => {
            const e = x({});
            return t.autocorrect().get((t => {
                t.fold((t => {
                    console.error("Error loading autocorrect list")
                }), (t => {
                    const r = ((t, e) => {
                        const r = {};
                        var o;
                        return ((t, e, r, o) => {
                            E(t, ((t, n) => {
                                (e(t, n) ? r : o)(t, n)
                            }))
                        })(t, e, (o = r, (t, e) => {
                            o[e] = t
                        }), O), r
                    })(t.corrections, ((t, e) => !(1 === t.length && e.length > 1)));
                    e.set(r)
                }))
            })), {lookup: t => u.from(e.get()[t])}
        })((t => {
            const e = (t => t.options.isSet("autocorrect_service_url") ? t.options.get("autocorrect_service_url") : t.options.get("autocorrect_rpc_url"))(t),
                r = (t => t.options.isSet("autocorrect_api_key") ? t.options.get("autocorrect_api_key") : t.options.get("api_key"))(t);
            var o;
            const n = (a = {
                url: `${[(o = e, h(o, "/") ? ((t, e) => t.substring(0, t.length - e))(o, "/".length) : o), tt].join("/")}/autocorrect?apiKey=${r}`,
                responseType: J.JSON,
                credentials: !0
            }, Y({...a, method: "get", body: {type: J.Text, data: ""}}));
            var a;
            return {autocorrect: b(n)}
        })(t));
        tinymce.PluginManager.add("autocorrect", (r => {
            if (((t, r) => !!t && -1 === ((t, r) => {
                const o = e(t.major, r.major);
                if (0 !== o) return o;
                const n = e(t.minor, r.minor);
                if (0 !== n) return n;
                const a = e(t.patch, r.patch);
                return 0 !== a ? a : 0
            })((t => o((t => [t.majorVersion, t.minorVersion].join(".").split(".").slice(0, 3).join("."))(t)))(t), o(r)))(tinymce, "6.2.0")) return void console.error("The autocorrect plugin requires at least version 6.2.0 of TinyMCE.");
            (t => {
                const e = t.options.register;
                e("autocorrect_api_key", {processor: "string"}), e("autocorrect_rpc_url", {
                    processor: "string",
                    default: ""
                }), e("autocorrect_service_url", {
                    processor: "string",
                    default: ""
                }), e("autocorrect_capitalize", {
                    processor: "boolean",
                    default: !1
                }), e("autocorrect_autocorrect", {processor: "boolean", default: !0})
            })(r);
            const n = (t => {
                const e = rt("autocorrect", t.autocorrect), r = rt("capitalize", t.capitalize);
                return {autocorrect: b(e), capitalize: b(r)}
            })({autocorrect: s(r), capitalize: a(r)});
            ((t, e) => {
                t.on("SpellcheckerLanguageChanged", (r => {
                    return o = r.language, void (g(o, "en") || (e.autocorrect().get() && _(t, e, {
                        on: !1,
                        cache: !1
                    }), e.capitalize().get() && w(t, e, {on: !1, cache: !1})));
                    var o
                }))
            })(r, n), ((t, e) => {
                t.ui.registry.addToggleMenuItem("autocorrect", {
                    text: "Autocorrect", onAction: () => {
                        ((t, e) => {
                            const r = e.autocorrect().get();
                            _(t, e, {on: !r, cache: !0})
                        })(t, e)
                    }, onSetup: r => {
                        const o = () => r.setActive(e.autocorrect().get());
                        return o(), t.on(d, o), () => t.off(d, o)
                    }
                }), t.ui.registry.addToggleMenuItem("capitalization", {
                    text: "Capitalization", onAction: () => {
                        ((t, e) => {
                            const r = e.capitalize().get();
                            w(t, e, {on: !r, cache: !0})
                        })(t, e)
                    }, onSetup: r => {
                        const o = () => r.setActive(e.capitalize().get());
                        return o(), t.on(m, o), () => t.off(m, o)
                    }
                })
            })(r, n);
            const c = ((t, e) => ({
                lookupPatterns: r => {
                    const o = [...e.autocorrect().get() ? [R(t)] : [], ...e.capitalize().get() ? [{
                        regexes: N.capitalisation,
                        identify: t => {
                            var e;
                            if (t.length >= 4) {
                                const r = t[1] + t[2] + t[3],
                                    o = t[1] + p(t[2]) + (null !== (e = t[3]) && void 0 !== e ? e : "");
                                return u.some({start: r, replacement: o})
                            }
                            return u.none()
                        }
                    }, {
                        regexes: N.normalisation, identify: t => {
                            var e;
                            if (t.length >= 4) {
                                const r = t[1] + t[2] + (null !== (e = t[3]) && void 0 !== e ? e : ""),
                                    o = p(r.toLowerCase());
                                return u.some({start: r, replacement: o})
                            }
                            return u.none()
                        }
                    }] : []];
                    return I(r, o)
                }
            }))(t(r), n), i = (t => t.options.get("text_patterns_lookup"))(r);
            r.options.set("text_patterns_lookup", (t => {
                const e = c.lookupPatterns(t.text);
                return [...i(t), ...e]
            }))
        }))
    })()
}();